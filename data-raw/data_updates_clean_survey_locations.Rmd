---
title: "feather river redd survey locations naming qc - adding names to data"
date: "2024-12-09"
rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE)

library(tidyverse)
library(lubridate)
library(ggplot2)
library(dplyr)
library(readxl)
library(sf)
library(leaflet)
library(openxlsx)
library(readxl)
```
The goal of this markdown is to clean up the location names from Feather River redd survey data.

Summary of work that has been done so far:

  * redd_qc_2014-2023 - mainly exploratory: 
    *  raw data is pulled in, negative velocity values are set to NA
    * pot_depth_m >= 40 is set to NA
    * "type" is removed
    
  * mapping_qc: looks into latitude longitude and identifies issues. 
    * Data file input: "data/archive/all_redd_data.csv" 
  * clean_locations: fixed latitude/longitude provided by Chris Cook, these changes address the issues found on mapping_qc. 
    * Data file input: "data/archive/all_redd_data.csv". 
    * Data file output(s): "data-raw/redd_observations_clean_locations.csv" and "data/redd_observations.csv" (`location`, `survey_wk` and `file_number` removed)
  
```{r, include=FALSE}
redd_observations <- read.csv("data-raw/redd_observations_clean_locations.csv")
```

Looking into unique location names

  * There are 81 unique names
  
```{r}
unique(redd_observations$location)
```

```{r, include=FALSE}
# removing spaces
redd_observations$location <- gsub(" ", "", redd_observations$location)

# Display the modified vector
print(unique(redd_observations$location))

```


Survey location names - redd data  locations will be matched to these names

```{r, echo=FALSE, message=FALSE}
# Names from survey location provided by Chris Cook
locations <- c(
  "UpperHatchery", "UpperCottonwood", "Hatchery", "Cottonwood",
  "TopofAuditorium", "MoesSideChannel", "UpperAuditorium", "MiddleAuditorium",
  "LowerAuditorium", "HatcheryPipe", "LowerTableMountain", "TableMountain",
  "BelowLowerAuditorium", "Bedrock", "TrailerPark", "UpperMathews",
  "Mathews", "UpperRobinson", "LowerRobinson", "Steep",
  "SteepSideChannel", "Weir", "Eye", "EyeSideChannel",
  "Gateway", "Aleck", "HatcherySideChannel", "VanceEast",
  "VanceWest", "BigHoleEast", "BigHoleWest", "BelowBigHoleEast",
  "G95WestSideChannel", "G95EastSideChannelTop", "G95EastSideChannelBottom", "UpperHour",
  "LowerHour", "Keister", "Goose", "Big",
  "LowerBig", "BigBar", "UpperMcFarland", "LowerMcFarland",
  "Developing"
)

locations <- tolower(locations)
table_data <- data.frame(
  ID = seq_along(locations), 
  Name = locations
)
table_data <- table_data[order(table_data$Name), ]

# Generate the sorted table
knitr::kable(table_data, col.names = c("ID", "Location Name"))
```

Identifying locations that do not match survey location names

```{r, echo=FALSE}
invalid_locations <- redd_observations$location[!redd_observations$location %in% locations]

# Display invalid locations
unique_invalid_locations <- unique(invalid_locations)
print(unique_invalid_locations)
```

```{r}
# renaming those that are just miss spelled 
redd_observations_clean_1 <- redd_observations |> 
  mutate(location = case_when(
    location == "aleckriffle" ~ "aleck",
    location == "bedrockriffle" ~ "bedrock",
    location == "bigriffle" | location ==	"bigbarriffle" ~	"bigbar",
    location == "g-95eastsidechannelbottom"	| location == "g95eastbottom"	~ "g95eastsidechannelbottom",
    location == "g-95easttop" | location == "g95easttop"	~ "g95eastsidechanneltop",
    location == "g-95westsidechannelbottom" | location ==	"g95west" | location ==	"g95westbottom" ~	"g95westsidechannel",
    location == "gooseriffle"	~	"goose",
    location == "hatcheryriffle" ~ "hatchery", # unsure relationship
    location == "hatcherysidechannelupper" ~	"hatcherysidechannel",
    location == "lowerbigriffle" ~	"lowerbig",
    location == "matthews" ~	"mathews",
    location == "midauditorium"| location == "midhour" ~	"middleauditorium", # unsure about midhour relationship
    location == "moe'ssidechannel" ~ "moessidechannel",
    location == "steepriffle"	~	"steep", # unsure
    location == "steepside" ~ "steepsidechannel", #unsure
    location == "topofaudtorium" ~ "topofauditorium",
    location == "upperhatcheryriffle" ~	"upperhatchery",
    location == "uppermatthews" ~	"uppermathews",
    location == "weirriffle"	~	"weir",
    TRUE ~ location)) 

print(unique(redd_observations_clean_1$location))
```


```{r}
# check again for those names that do not match
redd_observations_clean_1 |> 
 pull(location) %>%
  .[!. %in% locations] %>%
  unique()

 not_consistent_names <- redd_observations_clean_1 |> 
   filter(!location %in% locations)  # Keep only the rows with inconsistent location names


not_consistent_names <- st_as_sf(not_consistent_names, coords = c("longitude", "latitude"), crs = 4326)

         
```

```{r eval=FALSE, include=FALSE}
gdb_path <- "data-raw/shapefiles/b105_redd_survey_locations_maps_2021.gdb"

layers <- st_layers(gdb_path)$name
# Prep to plot map of survey locations
survey_locations_map <- leaflet() |> 
  addTiles() |> 
  setView(lng = -121.5695, lat = 39.3665, zoom = 10)

# Loop through each layer name and add it to the map
for (layer_name in layers) {
  # Read the layer
  shapefile <- st_read(dsn = gdb_path, layer = layer_name)

  # Transform to WGS84 (EPSG:4326) and remove the Z dimension
  shapefile <- st_transform(shapefile, crs = 4326) |> 
               st_zm(drop = TRUE, what = "ZM")

  # Add the polygons to the map
  survey_locations_map <- survey_locations_map |> 
    addPolygons(
      data = shapefile,
      fillColor = "lightblue",  
      color = "darkblue",
      weight = 2,               
      opacity = 1.0,            
      fillOpacity = 0.5,        
      group = layer_name,
      popup = paste("Layer Name: ", layer_name)
    )
}

# Add markers from 'not_consistent_names' to the map for each unique location
unique_locations <- unique(not_consistent_names$location)

for (location in unique_locations) {
  # Filter the data to get points for this specific location

  
  # Add the markers to the map with the location name as the group
  survey_locations_map <- survey_locations_map |> 
    addCircleMarkers(
      data = not_consistent_names,
      radius = 3,  # Adjust radius as needed
      color = "red",
      group = location,  # Group by the location name (group will be dynamically handled)
      popup = ~paste("Location: ", location, "<br>", "Date: ", date)
    )
}

# TODO fix boxes function
survey_locations_map <- survey_locations_map |> 
  addLayersControl(
    overlayGroups = unique_locations,  # The groups are the unique location names
    options = layersControlOptions(collapsed = TRUE)
  )

# Display the map
survey_locations_map
```

